# 모듈의 위치

레포지토리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 레포지토리를 구현한 클래스는 인프라스트럭처에 속한다. 
```
domain
ㄴ Model.class
ㄴ ModelRepository.interface
infra
ㄴ JpaModelRepository
```
> DIP에 따라 레포지토리 구현 클래스틑 인프라스트럭처 영역에 위치한다.
> 레포지토리 구현 클래스를 인프라스트럭처 영역에 위치 시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.
# 기본기능
리포지토리가 제공하는 기본 기능은 다음 두 가지다. 
- ID로 애그리거트 조회
- 애그리거트 저장

두 메서드를 위한 리포지토리 인터페이스는 
```java
public interface. OrderRepository {
  Order findById(OrderNo no);
  void save(Order order);
}
```
인터페이스는 애그리거트 루트를 기준으로 작성한다. 주문 애그리거트는 Order 루트 엔티티를 비롯해 OrderLine, Orderer, ShippingInfo 등 다양한 객체를 포함하는데, 이 구성요소중에서 루트 엔티티인
Order를 기준으로 리포지토리 인터페이스를 제공한다. 
<br>
<br>
애그리거트를 조회하는 기능의 이름을 지을 때 특별한 규칙은 없지만, 널리 사용되는 규칙은 'findBy프로퍼티이름(프로퍼티 값)'형식을 사용하는 것이다. 인터페이스는 ID로 애그리거트를 조회하는 메서드 이름을
findById()로 지정한다. 



# AttributeConverter를 이용한 밸류 매핑 처리

int, long , String, LocalDate와 같은 타입은 DB 테이블의 한 개 칼럼에 매핑된다. 이와 비슷하게 밸류 타입의 프로퍼티를 한 개 컬럼에 매핑해야 할 때도 있다. 
<br>
예를 들어 Length가 길이 값과 단위의 두 프로퍼티를 갖고 있는데 DB 테이블에는 한 개 컬럼에 '1000mm'와 같은 형식으로 저장할 수 있다.

```java
public class Length {
  private int value;
  private String unit;
}
```
두 개 이상의 프록퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑하려면 @Embeddable 애너테이션으로는 처리할 수 없다. 이럴 때 사용할 수 있는 것이 AtrributeConverter이다. 
AtrributeConverter는 밸류 타입과 칼럼 데이터 간의 변환을 처리하기 위한 기능을 정의 한다.

```java
public interface AttributeConverter<X, Y> {
  public Y ConvertToDatabaseColumn(X attribute);
  public X ConvertToEntityAttribute(X dbData);
}
```
타입 파라미터 X는 밸류 타입이고 Y는 DB 타입이다. public Y ConvertToDatabaseColumn() 메서드는 DB 칼럼 값을 밸류로 변환하는 기능을 구현한다. 
convertToEntityAttribute() 메서드는 DB 컬럼 값을 밸류로 변환하는 기능을 구현한다. 

<br>
<br>
Money 밸류 타입을 위한 AttributeConverter를 구현한 코드
```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {

    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return money == null ? null : money.getValue();
    }

    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null ? null : new Money(value);
    }
}
```

AttributeConverter 인터페이스를 구현한 클래스는 @Converter 애너테이션을 적용한다. @Converter 애터네이션의 autoApply 속성 값을 true로 지정하면 모델에 출현하는 모든 Money 타입의 
프로퍼티에 대해 MoneyConverter를 자동으로 적용한다. 

@Converter의 autoApply 속성을 false로 지정하면(default 값이 false다) 프로퍼티 값을 변환할 때 사용할 컨버터를 직접 지정해야한다.

```java
public class Order{
  ...
  @Column(name = "total_amounts")
  @Convert(converter = MoneyConverter.class) // autoApply를 false로 지정했을 경우
  private Money totalAmounts;
  
}
```

# 밸류 컬렉션: 별도 테이블 매핑

Order 엔티티는 한 개 이상의 OrderLine을 가질 수 있다. OrderLine에 순서가 있다면 다음과 같이 List타입을 이용해서 컬렉션을 프로퍼티로 지정할 수 있다. 

```java
public class Order{
  private List<OrderLine> orderLines;
  ...
}
```

밸류 컬렉션을 저장하는 ORDER_LINE 테이블은 외부키를 이용해서 엔티티에 해당하는 PURCHASE_ORDER 테이블을 참조한다. 이 외부키는 컬렉션이 속할 엔티티를 의미한다.
List 타입은 인덱스값이 필요하므로 line_idx 컬럼도 존재한다 .

```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Version
    private long version;

    @Embedded
    private Orderer orderer;

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
    ....
    
@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;

    @Convert(converter = MoneyConverter.class)
    @Column(name = "price")
    private Money price;

    @Column(name = "quantity")
    private int quantity;

    @Convert(converter = MoneyConverter.class)
    @Column(name = "amounts")
    private Money amounts;
    
    ...
```

# 밸류 컬렉션: 한 개 컬럼 매핑
밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야 할 때가 있다. 
<br>
예를 들어 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 컬럼에 콤마로 구분해서 저장해야 할 때가 있다. 이때 AttributeConverter를 사용하면 밸류 컬렉션을 한개 컬럼에 쉽게 매핑 
할 수 있다. 단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야한다. 
```java
public class EmailSet {
  private Set<Email> emails = new HashSet();
  
  public EmailSet(Set<email> emails){
    this.emails = emails;
  }
  
  public Set<Email> getEmails() {
    return Collections.unmodifiableSet(emails);
  }
}
```
밸류 컬렉션을 위한 타입을 추가했다면 AttributeConverter를 구현한다.

```java
public class EmailSetConverter implements AttributeConverter<EmailSet, String> {
  
  
  //디비에서 데이터를 꺼내어 사용할떄
  @Override
  public String convertTodatabaseColumn(EmailSet attribute){
    if(attribute == null) return null;
    return attribute.getEmails().stream()
                                .map(email -> email.getAddress())
                                .collect(Collectors.joining(","));
  }
  
  // 디비에 데이터를 넣을떄 
  @Override
  public EmailSet convertToEntityAttribute(String dbData){
    if(dbData == null) return null;
    String[] emails = dbData.split(",");
    Set<Email> emailSet = Arrays.stream(emails)
                                .map(value -> new Email(value))
                                .collect(toSet());
    return new EmailSet(emailSet);  
  }
}
```
> 이제 남은 것은 EmailSet 타입 프로퍼티가 Converter로 EmailSetConverter를 사용하도록 하는 것이다.

```java
@Column(name = "emails")
@Convert(Converter = EmailsSetConverter.class)
priavet EmailSet emailSet;
```
# 밸류를 이용한 ID매핑
식별자랄는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수도 있다. 밸류 타입을 식별자로 매핑하면 @Id대신 @EmbededId애너테이션을 이용한다.

```java
@Entity
@Table(name = "purchase_order")
public classs Order {
  @EmbededId
  private OrderNo number;
  ...
}

@Embedable
public class OrderNo implements Serializable{
  
  @Column(name = "order_number")
  private String number;
  ...
}
```
JPA에서는 식별자는 Serializable 타입이어야 하므로 상속 받아야한다. 
밸류 타입으로 식별자를 구현할떄는 식별자에 기능을 추가할 수 있다는 장점이 있다. 
예를 들어 1세대 시스템의 주문 번호와 2세대 시스템의 주문 번호를 첫 글자로 구분하여 사용할 경우 

```java

@Embedable
public class OrderNo implements Serializable{
  
  @Column(name = "order_number")
  private String number;

  public boolean is2ndGeneration() {
    return number.startWith("N");
  }
  ...
}
```











