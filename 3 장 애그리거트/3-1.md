# 애그리거트 

- 온라인 쇼핑몰 시스템을 개발할 때 상위 수준 개념(애그리거트 루트)을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 데 도움이 된다. 
- 더 많은 코드를 보고 도메인 전문가와 더 많은 대화를 나눠야 비로소 상위 수준에서 모델 간의 관계가 이해되기 시작한다. 

> 백 개 이상의 테이블을 한 장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터구조를 이해하는 데 어려움을 겪게 되는 것처럼, 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로
> 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워 진다.

**주요 도메인 요소간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워 진다는 것을 의미한다.**
그로 인해 세부적인 모델만 이해한 상태로는 코드를 수정하는 것이 꺼려지기 때문에 코드 변경을 최대한 **회피하는 쪽으로 요구사항을 협의 하게된다.**

- 복잡한 도메인을 이해가고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트다. 

## 도메인을 상위 수준에서 조망할 수 있는 애그리거트 

- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 **애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.** 예로 주문 애그리거트를 만들려면 Order, OrderLine, Orderer와 같은 관련 객체를 함께
생성해야 한다. Order는 생성했는데 ShippingInfo는 만들지 않거나 ShippingInfo를 생성하면서 Orderer를 생성하지 않는 경우는 없다. 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 
**애그리거트에 속한 구성요소는 대부분 함께 생성하고 함계 제거한다.**

- 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 이는 애그리거트는 자기 자신만을 관리할 뿐 **다른 애그리거트를 관리하지않는다(관여x).**
- 예로 '주문' 애그리거트는 배송지 변경이나 주문 상품 개수를 수정을 하는 등 자기 자신은 관리하지만, '회원'애그리거트에 속하는 회원 비밀번호 변경하거나 '상품'애그리거트에 속하는 상품 가격변경은 변경하지 않는다.

## 애그리거트는 경계를 가진다
경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규치에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 예를 들어 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 이들은 한 애그리거트다. 
- 또한 OrderLine의 주문 상품 개수를 변경하면 도메인 규칙에 따라 Order의 총 주문 금액을 새로 계산 해야한다.
- 사용자 요구사항에 따라 주문 상품 개수와 배송지를 함께 변경하기도 한다. 
> 이처럼 함께 변경되는 빈도가 높은 객체는 한 애그리거트일 가능성이 높다.

### 'A'가 'B'를 가진다
- 흔히 'A'가 'B'를 가진다로 설계할 수 있는 요구사항이 있다면 한 애그리거트로 묶어서 생각하기 쉽다. 주문(Order)가 주문정보(ShippingInfo)와 주문자(Orderer)를 가지고 있으므로 어느정도 타당하다.
하지만 개발에 무조건이라는 말이 없듯이 예외가 존재한다.

### 상품과 리뷰
- 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰내용을 보여줘야한다는 요구사항이 있을때 상품(Product)엔티티와 리뷰(Review)엔티티가 한 애그리거트에 속한다 생각할 수 있지만 이 둘은 함께 생성되지도
않고 함께 변경되지도 않는다. 
- 게다가 변경이나 수정의 주체 역시 다르다. Product는 상품 관리자가 Review는 고객이다. 
> 그러므로 Review와 Product는 서로의 상태에 영향을 주지 않아야 한다. 서로 다른 애그리거트이다.














