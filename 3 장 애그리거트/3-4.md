# ID를 이용한 애그리거트 참조
한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.
<br>
애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.
<br>
<br>
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.
<br>
예로 주문 애그리거트에서 Orderer는 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 Member를 필드로 참조할 수 있다.

```java
public class Order{
  @Embeded
  private Orderer orderer;
  ...
}

@Embedabel
public class Orderer{
  private Member member;
  private String name;
  ...
}

public class Member{
  ...
}
```
필드를 통해서 다른 애그리거트를 **직접** 참조하는 것은 개발자에게 구현의 편리함을 준다. 
<br>
<br>
예를 들어서 주문 정보를 조회해서 주문자의 ID값을 가져올떄 
```java
  order.getOrderer().getMember().getId();
```
이 처럼 아주 쉽게 구현 가능하다. *근데 프로그래밍은 역시 개발자가 힘들수록 안전하거나 성능이 좋거나 그렇다.*
필드를 통한 다른 애그리거트 참조는 다음의 문제를 야기할 수 있다.
## 편한 탐색 오용
- 편리함을 오용할 수 있다는것이 가장 큰 문제라고 필자는 얘기한다. 이전 장에서 언급한 애그리거트에서 다른 애그리거트의 상태를 변경하면 안된다는 것을 언급했었다.
 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야한다. 그런데 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다음 처럼 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.
 (나도 이렇게 많이 썼었는데 안되는 이유를 몰랐었다.아니 애초에 안된다는 생각을 못했다.)
 ```java
    public class Order{
      private Orderer orderer;
      
      public void changeShippingInfo(ShippingInfo newShippingInfo,
                                     boolean useNewShippingAddrAsMemberAddr){
        ...
        
        if(useNewShippingAddrAsMemberAddr){
          ...
          //한 애그리거트 내부에서 다른 애그리거트에 접근할 수 있으면, 
          //구현이 쉬워진다는 것 때문에 다른 애그리거트의 상태를 변경하는(찔린다..)
          //유혹에 빠지기 쉽다.(빠졌었다.)
        }
      }
    }
 ```
> 이는 쉽고 말고를 떠나서 시스템이 커지면 커질수록 성능이 중요해지면 중요해질수록 쓰면 안되는 이유가 조금 뒤에 나온다...
한 애그리거트에서 다른 애그리커트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
<br>
<br>











처음 3.4의 주제를 보고 음? 하는 생각이 들ㅇ
